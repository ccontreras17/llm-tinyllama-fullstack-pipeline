id,response
101,"Because 'unknown_variable' is not defined."
102,"def unique_order(lst): seen=set(); return [x for x in lst if not (x in seen or seen.add(x))]"
103,"result = [i*j for i in range(5) for j in range(5)]"
104,"def recursive_merge(d1,d2): from collections.abc import Mapping; for k,v in d2.items(): d1[k] = recursive_merge(d1.get(k,{}),v) if isinstance(v,Mapping) else v; return d1"
105,"It pairs elements from multiple iterables into tuples."
106,"from collections import Counter; def count_chars(s): return dict(Counter(s.lower()))"
107,"def sort_by_length(lst): return sorted(lst, key=len)"
108,"from collections import Counter; print(Counter(open('file.txt').read().split()).most_common(10))"
109,"'copy' creates a shallow copy; 'deepcopy' copies nested objects fully."
110,"def is_palindrome(lst): return lst == lst[::-1]"
111,"import re; def valid_email(s): return bool(re.match(r'^[\w.-]+@[\w.-]+\.\w+$', s))"
112,"A generator yields items lazily, lists store all items in memory."
113,"def intersect(a,b): return list(set(a)&set(b))"
114,"def make_incrementer(): counter=0; def inc(): nonlocal counter; counter+=1; return counter"
115,"def flatten_dict(d,p=''): items={}; [items.update(flatten_dict(v,f'{p}{k}.')) if isinstance(v,dict) else items.update({f'{p}{k}':v}) for k,v in d.items()]; return items"
116,"def evens_squared(lst): return [x**2 for x in lst if x%2==0]"
117,"*args collects positional args, **kwargs collects keyword args as dict."
118,"def is_ascii(s): return all(ord(c) < 128 for c in s)"
119,"from datetime import datetime; def date_diff(a,b): return abs((datetime.strptime(a,'%Y-%m-%d') - datetime.strptime(b,'%Y-%m-%d')).days)"
120,"They persist across calls, leading to unexpected behavior."
121,"def to_csv(lst): return ','.join(map(str,lst))"
122,"import string; def is_pangram(s): return set(string.ascii_lowercase) <= set(s.lower())"
123,"classmethod gets the class as the first arg; staticmethod gets nothing extra."
124,"def swap_dict(d): return {v:k for k,v in d.items()}"
125,"def longest_prefix(strs): from os.path import commonprefix; return commonprefix(strs)"
126,"A decorator wraps a function. Example: def deco(f): def wrap(*a,**kw): return f(*a,**kw); return wrap"
127,"import requests; open('file.txt','wb').write(requests.get('URL').content)"
128,"import json; def json_to_dict(s): return json.loads(s)"
129,"It initializes an object’s attributes when the class is instantiated."
130,"def sort_dicts(lst, key): return sorted(lst, key=lambda x: x[key])"
131,"from collections import namedtuple; Point = namedtuple('Point', 'x y'); p = Point(1,2)"
132,"It automatically opens and closes the file safely."
133,"from urllib.parse import parse_qs; def parse_query(q): return {k:v[0] for k,v in parse_qs(q).items()}"
134,"import statistics as s; def stats(lst): return s.mean(lst), s.median(lst), s.mode(lst)"
135,"__str__ is for user-friendly string, __repr__ is for debugging."
136,"def rotate(lst, n): return lst[-n:] + lst[:-n]"
137,"import re; def valid_ipv4(s): return bool(re.match(r'^(\d{1,3}\.){3}\d{1,3}$', s))"
138,"'is' checks identity, '==' checks equality."
139,"def remove_falsy(lst): return [x for x in lst if x]"
140,"def chunk(lst, size): return [lst[i:i+size] for i in range(0,len(lst),size)]"
141,"A lambda is an anonymous function: e.g. square = lambda x: x*x"
142,"import csv; [print(r) for r in csv.DictReader(open('file.csv')) if r['col'] == 'value']"
143,"def reverse_dict(d): return {v:k for k,v in d.items()}"
144,"It adds an index to items in a loop."
145,"def is_hex(s): return all(c in '0123456789abcdefABCDEF' for c in s)"
146,"def merge_sorted(a,b): return sorted(a+b)"
147,"If it walks like a duck and quacks like a duck, it’s a duck — behavior > type."
148,"import os; [os.rename(f, f.replace('.txt','_backup.txt')) for f in os.listdir() if f.endswith('.txt')]"
149,"import re; def strip_html(s): return re.sub(r'<[^>]*>','',s)"
150,"def substrings(s): return [s[i:j] for i in range(len(s)) for j in range(i+1,len(s)+1)]"
151,"GIL ensures only one thread executes Python bytecode at a time, limiting true parallelism."
152,"def lis(seq): from bisect import bisect_left; sub=[]; [sub.append(x) if not sub or x>sub[-1] else sub.__setitem__(bisect_left(sub,x),x) for x in seq]; return sub"
153,"import shutil; shutil.make_archive('archive','zip','folder_path')"
154,"def luhn(card): digits=[int(d) for d in str(card)][::-1]; return sum(d if i%2==0 else sum(divmod(d*2,10)) for i,d in enumerate(digits)) % 10 == 0"
155,"__getitem__ lets instances use indexing like obj[key] by defining it in the class."
156,"def catalan(n): from math import comb; return comb(2*n,n)//(n+1)"
157,"import psutil; [p.info for p in psutil.process_iter(['pid','name'])]"
158,"def is_symmetric(m): return m == [list(row) for row in zip(*m)]"
159,"Because NaN is not equal to anything, even itself (IEEE standard)."
160,"import xml.etree.ElementTree as ET; def extract_text(xml): return ''.join(ET.fromstring(xml).itertext())"
161,"import json; def save_json(d,f): json.dump(d, open(f,'w'), indent=2)"
162,"import hashlib; def sha256(s): return hashlib.sha256(s.encode()).hexdigest()"
163,"They manage resources using `with`; define __enter__ and __exit__ to make one."
164,"def has_cycle(g): visited=set(); def dfs(v, path): if v in path: return True; path.add(v); for n in g.get(v,[]): if dfs(n,path): return True; path.remove(v); return False; return any(dfs(n,set()) for n in g)"
165,"def hanoi(n,a,b,c): if n: hanoi(n-1,a,c,b); print(a,'->',c); hanoi(n-1,b,a,c)"
166,"super() accesses methods from the next class in MRO without explicit naming."
167,"from flask import Flask; app=Flask(__name__); @app.route('/')\ndef home(): return 'Hello'; app.run()"
168,"import psutil,time; [print(psutil.virtual_memory().used) or time.sleep(1) for _ in range(10)]"
169,"import pprint; def pretty(d): pprint.pprint(d, indent=2)"
170,"Changing or extending code at runtime, often used for quick hacks."
171,"def cache(f): memo={}; def wrap(*a): return memo[a] if a in memo else memo.setdefault(a, f(*a)); return wrap"
172,"import uuid; def is_uuid(s): try: uuid.UUID(s); return True; except: return False"
173,"def primes(n): return [x for x in range(2,n+1) if all(x%i for i in range(2,int(x**0.5)+1))]"
174,"map() returns a lazy iterator; list comps are clearer and often faster for simple tasks."
175,"import re; def valid_cron(expr): return bool(re.match(r'^(\S+\s+){4}\S+$', expr))"
176,"import markdown; def md_to_html(text): return markdown.markdown(text)"
177,"from tqdm import tqdm; [x for x in tqdm(range(1000))]"
178,"__slots__ restricts dynamic attribute creation and saves memory."
179,"def balance_parens(s): count=0; return all((count:=count+1 if c=='(' else count-1)>=0 for c in s if c in '()') and count==0"
180,"import random; rolls=[(random.randint(1,6), random.randint(1,6)) for _ in range(1000)]"
181,"Lists can change after creation; tuples are fixed (immutable)."
182,"import random,string; def gen_pw(n): return ''.join(random.choices(string.ascii_letters+string.digits,k=n))"
183,"def binary_search(lst,x): l,r=0,len(lst)-1; while l<=r: m=(l+r)//2; if lst[m]==x: return m; l,r = (m+1,r) if lst[m]<x else (l,m-1); return -1"
184,"import heapq; heap=[]; [heapq.heappush(heap,x) for x in [3,1,4]]"
185,"Coroutines can pause and resume with values using 'await'; generators use 'yield'."
186,"import os,hashlib; def dupes(path): seen={}; [seen.setdefault(hashlib.md5(open(f,'rb').read()).hexdigest(),[]).append(f) for f in os.listdir(path)]; return [v for v in seen.values() if len(v)>1]"
187,"import configparser; cfg=configparser.ConfigParser(); cfg.read('file.ini')"
188,"def levenshtein(a,b): dp=[[0]*(len(b)+1) for _ in range(len(a)+1)]; [dp[i].__setitem__(0,i) for i in range(len(a)+1)]; [dp[0].__setitem__(j,j) for j in range(len(b)+1)]; [[dp[i].__setitem__(j,min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(a[i-1]!=b[j-1]))) for j in range(1,len(b)+1)] for i in range(1,len(a)+1)]; return dp[-1][-1]"
189,"__enter__ sets up context, __exit__ tears it down (e.g. open files)."
190,"import re; def is_palindrome(s): s=re.sub(r'[^a-z0-9]','',s.lower()); return s==s[::-1]"
191,"import socket; def check_port(host,port): s=socket.socket(); return s.connect_ex((host,port))==0"
192,"def serialize(root): return preorder(root); def deserialize(data): pass  # Typically uses recursion and queue"
193,"async defines an async function; await pauses until result of async call."
194,"from itertools import permutations; def all_perms(lst): return list(permutations(lst))"
195,"import watchdog.events,watchdog.observers,time; class H(watchdog.events.FileSystemEventHandler): def on_modified(self,e): print('Changed:',e.src_path); obs=watchdog.observers.Observer(); obs.schedule(H(), path='.', recursive=True); obs.start(); time.sleep(10); obs.stop()"
196,"Caching technique that stores function results to avoid recalculation."
197,"def fib(n): a,b=[],0,1; [a.append(b) or (b:=a[-1]+b if a else 1) for _ in range(n)]; return a"
198,"def roman_to_int(s): m={'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}; total=0; prev=0; for c in reversed(s): val=m[c]; total += val if val >= prev else -val; prev=val; return total"
199,"yield pauses a function saving its state; resumes from there on next call."
200,"def balanced_brackets(s): stack=[]; pairs={')':'(','}':'{',']':'['}; for c in s: stack.append(c) if c in '({[' else (stack.pop() if stack and stack[-1]==pairs.get(c) else stack.append('?')); return not stack"

